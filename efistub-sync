#!/bin/bash
shopt -s nullglob

# SETTINGS
TARGET_DIR=/boot/efi/EFI
COMMAND_LINE="$(cat /proc/cmdline | tr -d '\n')"
OLD_STUBS_LIMIT=1

# Attempt to load the configuration file, if it's available
if [ -r "/etc/efistub-sync.conf" ]; then
	source "/etc/efistub-sync.conf"
fi

kernels=()
all_kernels=0

# Process the list of files modified in current run of pacman to figure out which kernels would be refreshed;
# the way the Pacman hook is set up, the targets will either be the vmlinuz files of kernel packages (in which case
# we want to generate new EFISTUB), or mkinitcpio/microcode files (in which case, initramfs for all kernels will be
# updated, so we want to generate new EFISTUB files for all)
while read -r line; do

	# Change to initcpio files, initramfs would be regenerated for all kernels
	if [[ $line != */vmlinuz ]]; then
		all_kernels=1
		break
	fi

	# Get pkgbase, skip if pkgbase does not exist
	if ! read -r pkgbase > /dev/null 2>&1 < "${line%/vmlinuz}/pkgbase"; then
		continue
	fi

	if [[ -f "/etc/mkinitcpio.d/$pkgbase.preset" ]]; then
		kernels+=("$pkgbase")
	fi

done

if (( all_kernels )); then
	kernels=()
	while read -r line; do
		kernels+=("$(basename "${line%.preset}")")
	done < <(ls "/etc/mkinitcpio.d/"*.preset)
fi

# Get the list of all microcode images currently residing in boot;
# they will be concatenated with initramfs into the EFISTUB, to ensure
# early loading of such fixes
readarray -t microcode < <(ls /boot/*ucode*)

# Create temporary directory for all the operations, and ensure it's correctly
# cleaned up and removed when the whole process is complete
tmpdir="$(mktemp -dt stubsync.XXXXXX)"
trap "rm -f $tmpdir/*; rmdir $tmpdir" EXIT HUP INT TERM

for kernel in "${kernels[@]}"; do

	echo "==> Updating EFISTUB for $kernel..."
	echo "    Generating EFISTUB file..."
	efi-mkuki -o "$tmpdir/efistub-$kernel.img" -c "$COMMAND_LINE" "/boot/vmlinuz-$kernel" "${microcode[@]}" "/boot/initramfs-$kernel.img"

	# Here we'll add Secure Boot signing

	checksum_new="$(sha256sum -b "$tmpdir/efistub-$kernel.img" | awk '{print $1}')"

	# If we don't have any previous stub of that type, just drop it into the expected location
	if [ ! -f "$TARGET_DIR/$kernel.efi" ]; then
		echo "    Deploying new EFISTUB..."
		mv "$tmpdir/efistub-$kernel.img" "$TARGET_DIR/$kernel.efi"
		echo "    EFISTUB files synchronised for $kernel"
	else

		readarray -t existing_stubs < <(ls "$TARGET_DIR/$kernel.efi"*)
		readarray -t existing_checksums < <(sha256sum "${existing_stubs[@]}" | awk '{print $1}')

		# State variable for how to proceed with the whole process:
		# 0 - we've found a match in active EFISTUB, meaning we don't have to do anything
		# 1 - we've found no match; existing files stay, new file is prepended to the beginning of the list
		# 2 - we've found a match in one of backups, need to renumerate the files so that that backup is active file
		renumerate=1

		for i in "${!existing_stubs[@]}"; do
			# Found match for the new file, perform reassignments if need be
			if [ "$checksum_new" == "${existing_checksums[$i]}" ]; then

				# If it matches the currently active EFISTUB, we don't do anything
				if [ "$i" == 0 ]; then
					echo "    Identical EFISTUB already deployed, no further action needed"
					renumerate=0
					break

				# If it matches a backup, we should move it to the beginning of the list
				# (so that it's renamed to the active EFISTUB is is thus being used)

				# If the last file in the array is matched, we've got one procedure to
				# shift it to the beginning; we "pop" it with unset, then redefine the array
				# with it at the beginning
				elif [ "$i" == "$(( "${#existing_stubs[@]}" - 1 ))" ]; then
					stub_to_move="${existing_stubs[$i]}"
					unset "existing_stubs[$i]"
					existing_stubs=("$stub_to_move" "${existing_stubs[@]}")
					echo "    EFISTUB already among backup files, reactivating it..."
					renumerate=2

				# If the item is matched in the middle of the array, then we pull it out
				# by redefining the array with two slices (one before, one after the items)
				else
					stub_to_move="${existing_stubs[$i]}"
					existing_stubs=("$stub_to_move" "${existing_stubs[@]:0:$i}" "${existing_stubs[@]:$((i+1)):${#existing_stubs[@]}}")
					echo "    EFISTUB already among backup files, reactivating it..."
					renumerate=2
				fi

			fi
		done

		# If we found no matches, prepend the file in temp directory to the list, so that
		# it gets moved to target directory and made active EFISTUB during renumeration
		if [ "$renumerate" == 1 ]; then
			echo "    Deploying new EFISTUB..."
			existing_stubs=("$tmpdir/efistub-$kernel.img" "${existing_stubs[@]}")
			renumerate=2
		fi

		if [ "$renumerate" == 2 ]; then

			for (( i=${#existing_stubs[@]}-1 ; i>=0 ; i-- )) ; do

				if [ "$i" -gt "$OLD_STUBS_LIMIT" ]; then

					# Only print the message about removing the files on the very
					# last element of the array; this guarantees that it's only going to be
					# printed once
					if [ "$i" == "$(( "${#existing_stubs[@]}" - 1 ))" ]; then
						echo "    Removing old EFISTUB backups..."
					fi
					rm "${existing_stubs[$i]}"

				else

					target_file="$TARGET_DIR/$kernel.efi$([ "$i" == 0 ] && echo "" || echo ".$i")"
					# We want to avoid clashes with movement overriding existing files,
					# so if destination file exists, add a suffix that will be removed in
					# additional pass
					if [ -f "$target_file" ]; then
						target_file="$target_file.temp"
					fi

					mv "${existing_stubs[$i]}" "$target_file"

				fi

			done

			# Remove any temporary prefixes added to prevent overriding files
			for item in "$TARGET_DIR/$kernel.efi"*.temp; do
				mv "$item" "${item%.temp}"
			done

			echo "    EFISTUB files synchronised for $kernel"
		fi

	fi

done
